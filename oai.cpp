// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <string>
#include <WinInet.h>
#include <vector>
#include <cstdlib>

#pragma comment(lib, "Wininet.lib")

bool CallOpenAICompletionAPI(const std::string& prompt, std::string& response) {
    HINTERNET hInternet = InternetOpen("WinInetOpenAIAgent", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (hInternet == NULL) {
        std::cerr << "InternetOpen failed. Error: " << GetLastError() << std::endl;
        return false;
    }

    std::string url = "https://api.openai.com/v1/engines/davinci-codex/completions";
    HINTERNET hConnect = InternetConnect(hInternet, "api.openai.com", INTERNET_DEFAULT_HTTPS_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
    if (hConnect == NULL) {
        std::cerr << "InternetConnect failed. Error: " << GetLastError() << std::endl;
        InternetCloseHandle(hInternet);
        return false;
    }

    LPCSTR acceptTypes[] = { "application/json", NULL };
    HINTERNET hRequest = HttpOpenRequest(hConnect, "POST", url.c_str(), "HTTP/1.1", NULL, acceptTypes, INTERNET_FLAG_SECURE | INTERNET_FLAG_RELOAD, 0);
    if (hRequest == NULL) {
        std::cerr << "HttpOpenRequest failed. Error: " << GetLastError() << std::endl;
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return false;
    }

    std::string authHeader = "Bearer <your_api_key_here>"; // Replace with your API key;
    if (!HttpAddRequestHeaders(hRequest, ("Authorization: " + authHeader).c_str(), -1, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE)) {
        std::cerr << "HttpAddRequestHeaders failed. Error: " << GetLastError() << std::endl;
        InternetCloseHandle(hRequest);
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return false;
    }

    std::string postData = R"(
    {
        "model": "text-davinci-003",
        "prompt": ")" + prompt + R"(",
        "temperature": 0.9,
        "max_tokens": 150,
        "top_p": 1,
        "frequency_penalty": 0,
        "presence_penalty": 0.6,
        "stop": [" Human:", " AI:"]
    }
    )";

    if (!HttpSendRequest(hRequest, NULL, 0, (LPVOID)postData.c_str(), postData.length())) {
        std::cerr << "HttpSendRequest failed. Error: " << GetLastError() << std::endl;
        InternetCloseHandle(hRequest);
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return false;
    }

    std::vector<char> buffer(4096);
    DWORD bytesRead;
    while (InternetReadFile(hRequest, &buffer[0], buffer.size(), &bytesRead) && bytesRead > 0) {
        response.append(buffer.begin(), buffer.begin() + bytesRead);
    }

    InternetCloseHandle(hRequest);
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);
    return true;
}


BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        MessageBoxA(NULL, "DLLMain!", "We've started.", 0);
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

extern "C" __declspec(dllexport) LPSTR CallOpenAICompletionAPIWrapper(LPCSTR lpPrompt) {
    LPSTR lpResponse = NULL;

    try {
        const std::string apiKey = "your_api_key_here"; // Replace with your actual API key
        std::string response;
        std::string prompt(lpPrompt);
        if (CallOpenAICompletionAPI(prompt, response)) {
            SIZE_T responseSize = response.size() + 1;
            lpResponse = new char[responseSize];
            memcpy(lpResponse, response.c_str(), responseSize);
        }
        else {
            MessageBoxA(NULL, "API call failed.", "Error", 0);
        }
    }
    catch (...) {
        MessageBoxA(NULL, "C++ Exception Thrown!", "Caught it", 0);
    }

    MessageBoxA(NULL, "I'm Leaving!", "Goodbye", 0);
    return lpResponse;
}
